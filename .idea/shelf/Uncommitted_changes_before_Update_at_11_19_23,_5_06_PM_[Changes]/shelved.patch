Index: system/soft/sim.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"m68k.h\"\n#include \"sim.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n\n\n#define MAX_ROM 0xfff                           /* Memory size for rom */\n#define MAX_RAM 0xffffff                            /* Memory size for ram */\n#define MAX_MEM (MAX_RAM)               /* ROM and RAM sizes */\n#define MEMAVAIL_ADDRESS 0x4100000C              /* Memory availble address */\n#define MEMAVAIL_VALUE_ADDRESS 0x41000010   /* Amount of memory configured */\n#define PLANEMASK_ADDRESS 0x410000B8          /* Plane mask address */\n#define PLANEMASK_VALUE_ADDRESS 0x410000C0    /* Plane mask value */\n#define BOOTARG_ADDRESS 0x410000D4            /* Boot argument address */\n#define BOOTARG_START 0x42000000                /* Boot argument start address */\n#define BOOTARG_END (BOOTARG_START + 64 - 1)  /* Boot argument end address */\n\n/* Read/write macros */\n#define READ_8(BASE, ADDR) (BASE)[ADDR]\n#define READ_16(BASE, ADDR) (((BASE)[ADDR] << 8) | (BASE)[(ADDR) + 1])\n#define READ_32(BASE, ADDR) (                            \\\n    ((BASE)[ADDR] << 24) |                               \\\n    ((BASE)[(ADDR) + 1] << 16) |                         \\\n    ((BASE)[(ADDR) + 2] << 8) |                          \\\n    (BASE)[(ADDR) + 3]                                   \\\n)\n\n#define WRITE_8(BASE, ADDR, VAL) (BASE)[ADDR] = (VAL)&0xff\n#define WRITE_16(BASE, ADDR, VAL) do {                   \\\n    (BASE)[ADDR] = ((VAL) >> 8) & 0xff;                  \\\n    (BASE)[(ADDR) + 1] = (VAL) & 0xff;                   \\\n} while(0)\n#define WRITE_32(BASE, ADDR, VAL) do {                   \\\n    (BASE)[ADDR] = ((VAL) >> 24) & 0xff;                 \\\n    (BASE)[(ADDR) + 1] = ((VAL) >> 16) & 0xff;           \\\n    (BASE)[(ADDR) + 2] = ((VAL) >> 8) & 0xff;            \\\n    (BASE)[(ADDR) + 3] = (VAL) & 0xff;                   \\\n} while(0)\n\n\n/* Prototypes DO WE NEED THESE HERE? apg*/\nvoid exit_error(char* fmt, ...);\nunsigned int  m68k_read_memory_8(unsigned int address);\nunsigned int  m68k_read_memory_16(unsigned int address);\nunsigned int  m68k_read_memory_32(unsigned int address);\nvoid m68k_write_memory_8(unsigned int address, unsigned int value);\nvoid m68k_write_memory_16(unsigned int address, unsigned int value);\nvoid m68k_write_memory_32(unsigned int address, unsigned int value);\nvoid data_bus_recorder(const char *string, unsigned int address, unsigned int size);\n\n/* initiallize memory array to 0 */\nunsigned char g_mem[MAX_MEM+1] = {0};                 /* Memory in one array */\nunsigned char bootarg[64] = {0};                            /* Boot argument */\n\n\n/* struct definition */\nstruct section {\n    const char* name;\n    unsigned int address;\n    unsigned int size;\n};\n\n/* PIOs */\nunsigned int OBIO_PIO0A\t= 0x00;\t/* PIO-0 port A */\nunsigned int OBIO_PIO0B\t= 0x00;\t/* PIO-0 port B */\nunsigned int OBIO_PIO0C\t= 0x00;\t/* PIO-0 port C*/\nunsigned int OBIO_PIO0\t= 0x00;\t/* PIO-0 control */\n\n/* track instruction execution */\nvoid instruction_hook(unsigned int pc)\n{\n    printf(\"Now executing PC vvv: %08x\\n\", pc);\n    if(pc == 70294)\n    {\n      printf(\"Starting pmap_kenter_pa()\\n\");\n    }\n   // unsigned int r = m68k_get_reg(NULL, M68K_REG_SRP);\n    // printf(\"Current value of D2: %08x\\n\",r);\n}\n\n/* Print the address and data bus */\nvoid data_bus_recorder(const char *string, unsigned int address, unsigned int size) {\n    if(address <= MAX_RAM)\n        {\n            printf(\"%s@RAM: %08x\", string, address);\n        \n        if(size == 1)\n        {\n            printf(\" value: %02x\\n\", (g_mem[address]) );\n        }\n        else if(size == 2)\n        {\n            printf(\" value: %02x%02x\\n\", g_mem[address], g_mem[address+1] );\n        }\n        else if(size == 4)\n        {\n            printf(\" value: %02x%02x%02x%02x\\n\", g_mem[address], g_mem[address+1], g_mem[address+2], g_mem[address+3]);\n        }\n    }    \n}\n\n/* Exit with an error message.  Use printf syntax. */\nvoid exit_error(char* fmt, ...)\n{\n    static int guard_val = 0;\n    char buff[100];\n    unsigned int pc;\n    va_list args;\n\n    if(guard_val)\n        return;\n    else\n        guard_val = 1;\n\n    /* FILE *out = stderr; */\n    FILE *out = stdout;\n    \n    va_start(args, fmt);\n    vfprintf(out, fmt, args);\n    va_end(args);\n    fprintf(out, \"\\n\");\n    pc = m68k_get_reg(NULL, M68K_REG_PPC);\n    m68k_disassemble(buff, pc, M68K_CPU_TYPE_68000);\n    fprintf(out, \"At %04x: %s\\n\", pc, buff);\n\n    exit(EXIT_FAILURE);\n}\n\n\n/*portA data 51000000 \nportA command 51000002\nportB data 51000001\nportB command 51000006 */\n\n/*strings used to store serial IO port writes*/\nchar *port_A_data, *port_B_data, *port_A_command, *port_B_command;\nsize_t port_A_data_n, port_A_data_p;\nsize_t port_B_data_n, port_B_data_p;\n\nsize_t port_A_data_size, port_A_command_size, port_B_data_size, port_B_command_size;\n#define BUF_STEP_SIZE 100\n\n/*used for appending commands and data to serial IO ports*/\nvoid append_to_string(char **dest, const char *src, size_t *dest_size) {\n   size_t dest_len = strlen(*dest);\n   size_t src_len = strlen(src);\n   if(dest_len + src_len + 1 > *dest_size)\n   {\n      char* temp = (char*)malloc(*dest_size + BUF_STEP_SIZE);\n      *dest_size += BUF_STEP_SIZE;\n      strcpy(temp, *dest);\n      strcat(temp, src);\n      free(*dest);\n      *dest = temp;\n   }\n   else\n   {\n      strcat(*dest, src);\n   }\n}\n\n/* read serial IO port define */\nunsigned char serial_IO_read(unsigned int address){\n    return 0xff; \n}\n\n\n/* write serial IO port define */\nvoid serial_IO_write(unsigned int address, unsigned char data){\n    char buffer[10];\n    sprintf(buffer, \"%c\", data);\n    switch (address){\n        case 0x51000000:\n            port_A_data_n++;\n            append_to_string(&port_A_data, buffer, &port_A_data_size);\n            if(data == '\\n')\n            {\n               printf(\"portA::\");\n               puts(port_A_data+port_A_data_p);\n               port_A_data_p = port_A_data_n;\n            }\n            return;\n        case 0x51000001:\n            port_B_data_n++;\n            append_to_string(&port_B_data, buffer, &port_B_data_size);\n            if(data == '\\n')\n            {\n               printf(\"portB::\");\n               puts(port_B_data+port_B_data_p);\n               port_B_data_p = port_A_data_n;\n            }\n            return;\n        case 0x51000002:\n            append_to_string(&port_A_command, buffer, &port_A_command_size);\n            return;\n        case 0x51000006:\n            append_to_string(&port_B_command, buffer, &port_B_command_size);\n            return;\n        default:\n            exit_error(\"temp error msg%08x\\n\", address);\n    }\n}\n\n\n/* check if it is requesting serial IO port */\nint serial_IO_check(unsigned int address) {\n    switch (address) {\n        case 0x51000000:\n        case 0x51000001:\n        case 0x51000002:\n        case 0x51000006:\n            return 1;\n        default:\n            return 0;\n    }\n}\n\n/* return PIO port define */\nunsigned int obio_pio_port(unsigned int address) {\n    switch (address) {\n        case 0x49000000:\n            printf(\"Read OBIO_PIO0A\\n\");\n            return OBIO_PIO0A;\n        case 0x49000001:\n            printf(\"Read OBIO_PIO0B\\n\");\n            return OBIO_PIO0B;\n        case 0x49000002:\n            printf(\"Read OBIO_PIO0C\\n\");\n            return OBIO_PIO0C;\n        case 0x49000003:\n            printf(\"Read OBIO_PIO0 Control\\n\");\n            return OBIO_PIO0;\n        default:\n            exit_error(\"Invalid OBIO PIO port address %08x\\n\", address);\n            return 0; //what should we return here?\n    }\n}\n\n\n/* write PIO port define */\nvoid obio_pio_port_write(unsigned int address, unsigned int value) {\n    switch (address) {\n        case 0x49000000:\n            printf(\"Write OBIO_PIO0A\\n\");\n            OBIO_PIO0A = value;\n            break;\n        case 0x49000001:\n            printf(\"Write OBIO_PIO0B\\n\");\n            OBIO_PIO0B = value;\n            break;\n        case 0x49000002:\n            printf(\"Write OBIO_PIO0C\\n\");\n            OBIO_PIO0C = value;\n            break;\n        case 0x49000003:\n            printf(\"Write OBIO_PIO0 Control\\n\");\n            OBIO_PIO0 = value;\n            break;\n        default:\n            exit_error(\"Invalid OBIO PIO port address %08x\\n\", address);\n    }\n}\n\n/* check if it is requesting OBIO PIO port */\nint obio_pio_port_check(unsigned int address) {\n    switch (address) {\n        case 0x49000000:\n        case 0x49000001:\n        case 0x49000002:\n        case 0x49000003:\n            return 1;\n        default:\n            return 0;\n    }\n}\n\n/* reads in 8 bits from memory array */\nunsigned int m68k_read_memory_8(unsigned int address) {\n    if(obio_pio_port_check(address)) return obio_pio_port(address);\n    else if(serial_IO_check(address)) return serial_IO_read(address);\n    else if (address >= MAX_MEM) {\n        if (address >= BOOTARG_START && address <= BOOTARG_END) {\n            return bootarg[address - BOOTARG_START];\n        }\n        exit_error(\"Attempted to read byte(read_8) from address %08x beyond memory size\\n\", address);\n    }\n    data_bus_recorder(\"m68k_read_memory_8\", address, 1);\n    return READ_8(g_mem, address);\n}\n\n/* reads in 16 bits from memory array */\nunsigned int m68k_read_memory_16(unsigned int address) {\n    if(obio_pio_port_check(address)) return obio_pio_port(address);\n    else if(serial_IO_check(address))return serial_IO_read(address);\n    else if (address >= MAX_MEM) {\n        exit_error(\"Attempted to read byte(read_16) from address %08x beyond memory size\\n\", address);\n    }\n    data_bus_recorder(\"m68k_read_memory_16\", address, 2);\n    return READ_16(g_mem, address);\n}\n\n/* reads in 32 bits from memory array */\nunsigned int m68k_read_memory_32(unsigned int address) {\n    if(obio_pio_port_check(address)) return obio_pio_port(address);\n    else if(serial_IO_check(address))return serial_IO_read(address);\n    else if (address >= MAX_MEM) {\n        if(address == MEMAVAIL_ADDRESS) {\n            printf(\"Read 32 from MEMAVAIL_ADDRESS (%08x) value: %08x\\n\",MEMAVAIL_ADDRESS, MEMAVAIL_VALUE_ADDRESS);\n            return MEMAVAIL_VALUE_ADDRESS;\n        }\n        else if(address == MEMAVAIL_VALUE_ADDRESS) {\n            printf(\"Read 32 from MEMAVAIL_VALUE_ADDRESS (%08x) value: %08x\\n\", MEMAVAIL_VALUE_ADDRESS, MAX_MEM+1);\n            return MAX_MEM+1;\n        }\n        else if(address == PLANEMASK_ADDRESS) {\n            printf(\"Read 32 from PLANEMASK_ADDRESS (%08x) value: %08x\\n\", PLANEMASK_ADDRESS, PLANEMASK_VALUE_ADDRESS);\n            return PLANEMASK_VALUE_ADDRESS;\n        }\n        else if(address == PLANEMASK_VALUE_ADDRESS) {\n            printf(\"Read 32 from PLANEMASK_VALUE_ADDRESS (%08x) value: %08x\\n\", PLANEMASK_VALUE_ADDRESS, 0xff);\n            return 0xff;\n        }\n        else if(address == BOOTARG_ADDRESS) {\n            printf(\"Read 32 from BOOTARG_ADDRESS (%08x) value: %08x\\n\", BOOTARG_ADDRESS, BOOTARG_START);\n            return BOOTARG_START;\n        }\n        else exit_error(\"Attempted to read byte(read_32) from address %08x beyond memory size\\n\", address);\n    }\n    data_bus_recorder(\"m68k_read_memory_32\", address, 4);\n    return READ_32(g_mem, address);\n}\n\n/* write in 8 bits to memory array */\nvoid m68k_write_memory_8(unsigned int address, unsigned int value) {\n    if(obio_pio_port_check(address)) {\n        obio_pio_port_write(address, value);\n        return;\n    }\n    else if(serial_IO_check(address)){\n        serial_IO_write(address, value);\n        return;\n    }\n    if (address > MAX_MEM) {\n        exit_error(\"Attempted to write byte to address %08x beyond memory size\\n\", address);\n    }\n    // Check if the address is within the ROM range\n    if (address <= MAX_ROM) {\n        exit_error(\"Attempted to write byte to ROM address %08x\", address);\n    }\n    WRITE_8(g_mem, address, value);\n    data_bus_recorder(\"m68k_write_memory_8\", address, 1);\n}\n\n/* write in 16 bits to memory array */\nvoid m68k_write_memory_16(unsigned int address, unsigned int value) {\n    if(obio_pio_port_check(address)) {\n        obio_pio_port_write(address, value);\n        return;\n    }\n    else if(serial_IO_check(address)){\n        serial_IO_write(address, value);\n        return;\n    }\n    if (address > MAX_MEM) {\n        exit_error(\"Attempted to write byte to address %08x beyond memory size\\n\", address);\n    }\n    // Check if the address is within the ROM range\n    if (address <= MAX_ROM) {\n        exit_error(\"Attempted to write byte to ROM address %08x\", address);\n    }\n    WRITE_16(g_mem, address, value);\n    data_bus_recorder(\"m68k_write_memory_16\", address, 2);\n}\n\n/* write in 32 bits to memory array */\nvoid m68k_write_memory_32(unsigned int address, unsigned int value) {\n    if(obio_pio_port_check(address)) {\n        obio_pio_port_write(address, value);\n        return;\n    }\n    else if(serial_IO_check(address)){\n        serial_IO_write(address, value);\n        return;\n    }\n    if (address > MAX_MEM) {\n        exit_error(\"Attempted to write byte to address %08x beyond memory size\\n\", address);\n    }\n    // Check if the address is within the ROM range\n    if (address <= MAX_ROM) {\n        exit_error(\"Attempted to write byte to ROM address %08x\", address);\n    }\n    WRITE_32(g_mem, address, value);\n    data_bus_recorder(\"m68k_write_memory_32\", address, 4);\n}\n\nunsigned int m68k_read_disassembler_16(unsigned int address)\n{\n    if(address > MAX_ROM)\n        exit_error(\"Disassembler attempted to read word from ROM address %08x\\n\", address);\n    return READ_16(g_mem, address);\n}\n\nunsigned int m68k_read_disassembler_32(unsigned int address)\n{\n    if(address > MAX_ROM){\n        exit_error(\"Disassembler attempted to read long from ROM address %08x\\n\", address);\n    }\n    return READ_32(g_mem, address);\n}\n\n/* The sections to load */\nstruct section sections[] = {\n        {\"text\", 0x0000c000, 0x001f5bfc},\n        {\"rodata\", 0x00201c00, 0x0002f885},\n        {\"link_set_sysctl_funcs\", 0x00231488, 0x000000c8},\n        {\"link_set_modules\", 0x00231550, 0x00000108},\n        {\"link_set_domains\", 0x00231658, 0x00000020},\n        {\"link_set_evcnts\", 0x00231678, 0x00000048},\n        {\"link_set_dkwedge_methods\", 0x002316c0, 0x00000004},\n        {\"link_set_prop_linkpools\", 0x002316c4, 0x00000020},\n        {\"data\", 0x00231740, 0x00016b8c},\n        {\"bss\", 0x00248300, 0x00018858},\n};\n\n/* Load a section from a file into memory */\nvoid load_section(const struct section* sec) {\n    char filepath[128];\n    snprintf(filepath, sizeof(filepath), \"./bins/%s.bin\", sec->name);\n\n    FILE *fhandle = fopen(filepath, \"rb\");\n    if (!fhandle) {\n        exit_error(\"Unable to open %s\", filepath);\n    }\n\n    fread(&g_mem[sec->address], 1, sec->size, fhandle);\n    fclose(fhandle);\n}\n\nint main(int argc, char* argv[]) {\n   port_A_data = (char *)malloc(BUF_STEP_SIZE);\n   port_A_command = (char *)malloc(BUF_STEP_SIZE);\n   port_B_data = (char *)malloc(BUF_STEP_SIZE);\n   port_B_command = (char *)malloc(BUF_STEP_SIZE);\n   \n   port_A_data_p = port_A_data_n = 0;\n   port_B_data_p = port_A_data_n = 0;\n   \n   port_A_data_size =  port_A_command_size = port_B_data_size = port_B_command_size = BUF_STEP_SIZE;\n      \n    unsigned int text_section_address = 0x0000c000; // Example address\n\n    // Convert the address to bytes and store it at memory[4] to memory[7]\n    WRITE_32(g_mem, 4, text_section_address);\n    for (unsigned long i = 0; i < sizeof(sections) / sizeof(sections[0]); i++) {\n        load_section(&sections[i]);\n    }\n    m68k_init();\n    m68k_set_cpu_type(M68K_CPU_TYPE_68030);\n    m6sx8k_pulse_reset();\n\n    while(TRUE){\n        m68k_execute(100000);\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/system/soft/sim.c b/system/soft/sim.c
--- a/system/soft/sim.c	(revision c667146dfa5424d705379aa1d6e8a8fc6d664824)
+++ b/system/soft/sim.c	(date 1700442387964)
@@ -4,6 +4,7 @@
 #include <stdlib.h>
 #include <stdarg.h>
 #include <string.h>
+#include "c_compat.hpp"
 
 
 #define MAX_ROM 0xfff                           /* Memory size for rom */
Index: system/compact/c_compat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/system/compact/c_compat.cpp b/system/compact/c_compat.cpp
new file mode 100644
--- /dev/null	(date 1700442387986)
+++ b/system/compact/c_compat.cpp	(date 1700442387986)
@@ -0,0 +1,12 @@
+#include "c_compat.hpp"
+#include "memory.hpp"
+
+unsigned int  m68k_read_memory_8(unsigned int address){
+    return Memory::read8(size_t address);
+}
+unsigned int  m68k_read_memory_16(unsigned int address);
+unsigned int  m68k_read_memory_32(unsigned int address);
+void m68k_write_memory_8(unsigned int address, unsigned int value);
+void m68k_write_memory_16(unsigned int address, unsigned int value);
+void m68k_write_memory_32(unsigned int address, unsigned int value);
+void data_bus_recorder(const char *string, unsigned int address, unsigned int size);
\ No newline at end of file
Index: system/compact/c_compact.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/system/compact/c_compact.hpp b/system/compact/c_compact.hpp
new file mode 100644
--- /dev/null	(date 1700442387979)
+++ b/system/compact/c_compact.hpp	(date 1700442387979)
@@ -0,0 +1,16 @@
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+unsigned char serial_IO_read(unsigned int address);
+void serial_IO_write(unsigned int address, unsigned char data);
+int serial_IO_check(unsigned int address);
+
+unsigned int obio_pio_port(unsigned int address);
+void obio_pio_port_write(unsigned int address, unsigned int value);
+int obio_pio_port_check(unsigned int address);
+void databus_recorder(const char *string, unsigned int address, unsigned int size);
+
+#ifdef __cplusplus
+}
+#endif
\ No newline at end of file
diff --git a/CPU/m68k/luna_cpu.cpp b/CPU/m68k/luna_cpu.cpp
new file mode 100644
